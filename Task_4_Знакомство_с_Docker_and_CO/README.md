# Список вопросов:

## 1. Вопросы по docker-compose
```console
Вопрос 1.1. Что это вообще такое?
Вопрос 1.2. Как его запускать?
Вопрос 1.3. Как его останавливать?
Вопрос 1.4. После первого запуска остановил и поменял файл default.conf, почему настройки не применились?

version: "2.4"

# Вопрос 1.5. Можно ли собрать и запустить эти два докера без docker-compose?
# Вопрос 1.6. И вообще, почему docker-compose иногда пишут без минуса?
services:
# Вопрос 1.7. в чём отличие строки ниже от "image: front-nginx", "context: nginx" и "hostname: front-nginx"? Вроде везде nginx какой-то.
  nginx:
    image: front-nginx
    build:
      context: nginx
    hostname: front-nginx
    restart: unless-stopped
    ports:
# Вопрос 1.8. Почему переменная только в левой части?
      - ${API_PORT}:80
    environment:
# Вопрос 1.9. А это зачем? Мы же переменную порта выше указали.
      API_PORT: ${API_PORT}
    depends_on:
      - upstream-debian
# Вопрос 1.10. Основное задание!!! - Нужно добавить apache на сентос.
      # - upstream-centos

  upstream-debian:
# Вопрос 1.11. Как добавить несколько экземпляров apache на дебиан?
    image: upstream-debian
    build:
      context: debian
    hostname: upstream
    restart: unless-stopped
```

## 1. Ответы
#### Вопрос 1.1. 
Это docker-compose.yml. Основной документ для docker compose, цель которого - одновременно запустить несколько разных контейнеров (и, соответственно, подготовить все для их запуска, в т.ч. собрать образ, настроить сети и тома при необходимости), также с помощью этого документа мы при необходимости можем выстроить логику их запуска (какой контейнер стартуем первым, какой вторым итд). 
Все это позволяет запускать микросервисные приложения, сервисы которых крутятся в контейнерах.

#### Вопрос 1.2. 
Запустить можно с помощью `docker-compose up` (контейнеры займут командную строку) и `docker-compose up -d` (запуск контейнеров в фоновом режиме)

#### Вопрос 1.3. 
Если мы хотим просто остановить контейнеры, но не удалять их - `docker-compose stop`, но я не видела, чтобы так делали. 
Для полной остановки и удаления контейнеров - `docker-compose down`.

#### Вопрос 1.4.
`docker-compose up` при первом использовании собирает образы и на их основе запускает контейнеры. Если мы остановим контейнеры с помощью `docker-compose down`, то контейнеры остановятся и удалятся, это говорит нам о том, что и вся информация, которая была в контейнере тоже удалится. А вот образы, на основе которых были собраны контейнеры останутся и не изменятся. И при последующем выполнении `docker-compose up` все контейнеры собираются заново, но делают они это на основе уже существующих образов, которые остались без измнений. И в данном случае наш образ для контейнера nginx не в курсе, о каких-либо изменениях, которые мы делали внутри контейнера с nginx. Насколько я поняла, это как раз ключевой подход в докере. Неважно, что мы там поломаем к контейнере, при перезапуске, у нас снова будет работающий контейнер без наших поломок.

В данном случае, если мы хотим внести изменения на постоянной основе, нам надо пересобрать сам образ. Для этого нужно остановить контейнеры, внести изменения в нужный Dockerfile (замена / добавление инфы в default.conf или копирование нового конфига взамен стандартного).
И дальше, чтобы, собственно, пересобрать сам образ, надо стартануть контейнеры с помощью флага `--build`, тогда мы пересоберем образы, и изменения подтянутся: `docker-compose up --build`

#### Вопрос 1.5. 
Да. Для каждого контейнера у нас прописан Dockerfile, на его основе мы запускаем сборку образа (image), на основе готового образа собираем контейнеры. 
В данном примере нам важен порядок запуска контейнеров (т.к. прописан параметр `depends_on`), и важно, чтобы сначала запустился контейнер `upstream-debian` и `upstream-centos`, а потом `nginx`. Значит, ручками запускаем их в таком порядке. 
Если нам важно, чтобы контейнеры работали в одной сети, то без docker compose нам нужно самостоятельно создать пользовательскую сеть и подключить контейнеры к ней. 
Либо старым способом связать их с помощью параметра `--link` при `docker run` (я прочитала, что это уже deprecated).

#### Вопрос 1.6. 
docker-compose - это надстройка над докером, а docker compose - это инструмент самого докера, который вышел гораздо позднее. Выполняют одинаковую функцию.
Как я понимаю, докер рекомендует переходить на их технологию, но в более ранних версиях нужно использовать именно docker-compose.
Большинство команд идентичны, разная только начинка под капотом.

#### Вопрос 1.7. 
```console
  nginx: # название сервиса, может быть любым, но лучше, чтобы было понятным и по делу
    image: front-nginx # cам по себе указывает на образ, который используется для создания контейнера, 
                       # но вместе с build по сути дожидается сборки контейнера и задает имя образу
    build:
      context: nginx # директория, в которой лежит Dockerfile для сборки, отсчитывается с директории, где лежит сам docker-compose.yml
    hostname: front-nginx # а это имя контейнера в докер сети для общения с другими контейнерами в эттой сети
```

#### Вопрос 1.8. 
Видимо, потому что мы хотим дать себе возможность менять порт, на котором nginx будет слушать. Я думаю, это удобно при масштабировании или дальнейшей реструктуризации кода. Например, в приложение добавится еще несколько контейнеров и нам нужно будет по другому упорядлочить их порты, в том числе заменить их на другие. 
Саму переменную я нашла, она тусуется со всеми переменными (будущими) отдельно в `.env`.

#### Вопрос 1.9. 
Выше мы указали порты для запуска контейнера. Это аналогично тому, как если бы мы сделали `docker run -p 8080:80 nginx`. А сейчас мы эту переменную прокидываем в сам контейнер, чтобы у него появилась такая переменная окружения, и он мог с ней работать. Например, ее уже можно указать в `default.conf` для nginx. 
Еще я увидела ее в Dockerfile, но по умолчанию там она не будет работать, потому что логика сборки контейнера такая: сначала создается образ, на его основе создается контейнер. И переменная будет доступна в самом контейнере. А на этапе сборки образа мы о ней ничего не знаем (и Docker тоже). Если мы хотим, чтобы наша переменная окружения была доступна на этапе сборки образа, в Dockerfile, то так тоже можно, только для этого надо объявить ее в инструкции `ARG`.

#### Вопрос 1.10. 
В работе

#### Вопрос 1.11. 
Самое удобное и современное - использовать Swarm Mode, тогда можно добавить секцию `deploy` и в ней указать, сколько экземпляров (реплик) мы хотим запустить на основе одного Dockerfile. Если Swarm нам недоступен, то второй по приоритетности вариант - при запуске контейнеров использовать опцию `--scale`, чтобы с ее помощью указать, сколько экземпляров и какого именно контейнера нам нужно, например, `docker-compose up --scale upstream-debian=3`.

И третий способ - рабочий, но громоздкий. Так как `upstream-debian` отвечает за один контейнер, то если нам нужно несколько контейнеров, можно написать несколько таких секций вручную: `upstream-debian_1`, `upstream-debian_2` итд. Но devops - это про автоматизацию, а такой подход явно нет, поэтому просто упомянула, что технически это возможно, но не нужно.
Условно, так:
```console
  upstream-debian_1:
    image: upstream-debian
    build:
      context: debian
    hostname: upstream
    restart: unless-stopped

  upstream-debian_2:
    image: upstream-debian
    build:
      context: debian
    hostname: upstream
    restart: unless-stopped
```

## 2. Вопросы по Dockerfile в директории nginx
```console
# Вопрос 2.1. Как посмотреть размер образа?
# Вопрос 2.2. Нужно уменьшить суммарный размер образов основанных на debian, какие есть пути решения?
# Вопрос 2.3. Нужно уменьшить размер каждого образа, какие есть пути решения?
FROM debian:bookworm-backports

ARG DEBIAN_FRONTEND=noninteractive

LABEL maintainer="v.pukin@test.ru"

# Вопрос 2.4. Линтер ругается на строку ниже, хотя она работает. Что может быть не так?
RUN apt update &&\
    apt -y install --no-install-recommends \
        apache2 \
        nano \
        vim-tiny &&\
    apt clean &&\
    rm -rf /var/lib/apt/lists/*

# Вопрос 2.5. Чем отличаются ENV от ARG?
ENV APACHE_RUN_USER www-data
# Вопрос 2.6. Как перенести переменные отсюда в .env?
ENV APACHE_RUN_GROUP www-data
ENV APACHE_LOG_DIR /var/log/apache2
ENV APACHE_RUN_DIR /usr/sbin/
ENV APACHE_PID_FILE /tmp/apache.pid

CMD ["apache2", "-D", "FOREGROUND"]
```
## 2. Ответы  
#### Вопрос 2.1.
#### Вопрос 2.2.
#### Вопрос 2.3.
#### Вопрос 2.4.
#### Вопрос 2.5.
#### Вопрос 2.6.

## 3. Вопросы по Dockerfile в директории debian
```console
FROM nginx:1.24.0

ARG DEBIAN_FRONTEND=noninteractive

LABEL maintainer="v.pukin@test.ru"

RUN apt update &&\
    apt -y install --no-install-recommends \
        nano \
        vim-tiny &&\
    apt clean &&\
    rm -rf /var/lib/apt/lists/*

# Вопрос 3.1. - со звёздочкой - хочу сделать единый файл конфига для debian и centos, как?
COPY default.conf /etc/nginx/conf.d/

# Вопрос 3.2. Хотели менять переменную порта, но что-то не сложилось. Можно поиспользовать в проекте.
# CMD sed -i "s/API_PORT_REPLACE/${API_PORT}/" /etc/nginx/conf.d/default.conf &&\
```

## 3. Ответы 
#### Вопрос 3.1.
#### Вопрос 3.2.