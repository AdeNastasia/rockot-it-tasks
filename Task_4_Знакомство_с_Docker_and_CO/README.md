# Список вопросов:

## 1. Вопросы по docker-compose
```console
# Вопрос 1.1. Что это вообще такое?
# Вопрос 1.2. Как его запускать?
# Вопрос 1.3. Как его останавливать?
# Вопрос 1.4. После первого запуска остановил и поменял файл default.conf, почему настройки не применились?

version: "2.4"

# Вопрос 1.5. Можно ли собрать и запустить эти два докера без docker-compose?
# Вопрос 1.6. И вообще, почему docker-compose иногда пишут без минуса?
services:
# Вопрос 1.7. в чём отличие строки ниже от "image: front-nginx", "context: nginx" и "hostname: front-nginx"? Вроде везде nginx какой-то.
  nginx:
    image: front-nginx
    build:
      context: nginx
    hostname: front-nginx
    restart: unless-stopped
    ports:
# Вопрос 1.8. Почему переменная только в левой части?
      - ${API_PORT}:80
    environment:
# Вопрос 1.9. А это зачем? Мы же переменную порта выше указали.
      API_PORT: ${API_PORT}
    depends_on:
      - upstream-debian
# Вопрос 1.10. Основное задание!!! - Нужно добавить apache на сентос.
      # - upstream-centos

  upstream-debian:
# Вопрос 1.11. Как добавить несколько экземпляров apache на дебиан?
    image: upstream-debian
    build:
      context: debian
    hostname: upstream
    restart: unless-stopped
```

## 1. Ответы
#### Вопрос 1.1. 
Это docker-compose.yml. Основной документ для docker compose, цель которого - одновременно запустить несколько разных контейнеров (и, соответственно, подготовить все для их запуска, в т.ч. собрать образ, настроить сети и тома при необходимости), также с помощью этого документа мы при необходимости можем выстроить логику их запуска (какой контейнер стартуем первым, какой вторым итд). 
Все это позволяет запускать микросервисные приложения, сервисы которых крутятся в контейнерах.

#### Вопрос 1.2. 
Запустить можно с помощью `docker-compose up` (контейнеры займут командную строку) и `docker-compose up -d` (запуск контейнеров в фоновом режиме)

#### Вопрос 1.3. 
Если мы хотим просто остановить контейнеры, но не удалять их - `docker-compose stop`, но я не видела, чтобы так делали. 
Для полной остановки и удаления контейнеров - `docker-compose down`.

#### Вопрос 1.4.
`docker-compose up` при первом использовании собирает образы и на их основе запускает контейнеры. Если мы остановим контейнеры с помощью `docker-compose down`, то контейнеры остановятся и удалятся, это говорит нам о том, что и вся информация, которая была в контейнере тоже удалится. А вот образы, на основе которых были собраны контейнеры останутся и не изменятся. И при последующем выполнении `docker-compose up` все контейнеры собираются заново, но делают они это на основе уже существующих образов, которые остались без изменений. И в данном случае наш образ для контейнера nginx не в курсе, о каких-либо изменениях, которые мы делали внутри контейнера с nginx (т.к. эта информация удалилась). 
Насколько я поняла, это как раз ключевой подход в докере. Неважно, что мы там поломаем к контейнере, при перезапуске, у нас снова будет работающий контейнер без наших поломок.

В данном случае, если мы хотим внести изменения на постоянной основе, нам надо пересобрать сам образ. Для этого нужно:
* остановить контейнеры: `docker-compose down`, 
* внести изменения в нужный Dockerfile (замена / добавление инфы в default.conf или копирование нового конфига взамен стандартного).
* и стартануть контейнеры с помощью флага `--build`: `docker-compose up --build` - с помощьюю этого флага мы пересоберем образы, и изменения подтянутся 

#### Вопрос 1.5. 
Да. Для каждого контейнера у нас прописан Dockerfile, на его основе мы запускаем сборку образа (image), на основе готового образа собираем контейнеры. 
В данном примере нам важен порядок запуска контейнеров (т.к. прописан параметр `depends_on`), и важно, чтобы сначала запустился контейнер `upstream-debian` и `upstream-centos`, а потом `nginx`. Значит, ручками запускаем их в таком порядке. 
Если нам важно, чтобы контейнеры работали в одной сети, то без docker compose нам нужно самостоятельно создать пользовательскую сеть и подключить контейнеры к ней. 
Либо старым способом связать их с помощью параметра `--link` при `docker run` (я прочитала, что это уже deprecated).

Также я потом добавила тома, это нужно будет указать при старте контейнеров также.

#### Вопрос 1.6. 
docker-compose - это надстройка над докером, а docker compose - это инструмент самого докера, который вышел гораздо позднее. Выполняют одинаковую функцию.
Как я понимаю, докер рекомендует переходить на их технологию, но в более ранних версиях нужно использовать именно docker-compose.
Большинство команд идентичны, разная только начинка под капотом.

#### Вопрос 1.7. 
```console
  nginx: # название сервиса, может быть любым, но лучше, чтобы было понятным и по делу
    image: front-nginx # cам по себе указывает на образ, который используется для создания контейнера, 
                       # но вместе с build по сути дожидается сборки контейнера и задает **имя** образу
    build:
      context: nginx # директория, в которой лежит Dockerfile для сборки, отсчитывается с директории, где лежит сам docker-compose.yml
    hostname: front-nginx # а это имя контейнера в докер сети для общения с другими контейнерами в этой сети
```

#### Вопрос 1.8. 
Видимо, потому что мы хотим дать себе возможность менять порт, на котором nginx будет слушать. Я думаю, это удобно при масштабировании или дальнейшей реструктуризации кода. Например, в приложение добавится еще несколько контейнеров и нам нужно будет по другому упорядлочить их порты, в том числе заменить их на другие. 
Саму переменную я нашла, она тусуется со всеми переменными (будущими) отдельно в `.env`.

#### Вопрос 1.9. 
Выше мы указали порты для запуска контейнера. Это аналогично тому, как если бы мы сделали `docker run -p 8080:80 nginx`. А сейчас мы эту переменную прокидываем в сам контейнер, чтобы у него появилась такая переменная окружения, и он мог с ней работать. Например, ее уже можно указать в `default.conf` для nginx (но, видимо, не просто напрямую, с этим пока разбираюсь). 

Еще я увидела ее в Dockerfile, но по умолчанию там она не будет работать, потому что логика сборки контейнера такая: сначала создается образ, на его основе создается контейнер. И переменная будет доступна в самом контейнере. А на этапе сборки образа мы о ней ничего не знаем (и Docker тоже). Если мы хотим, чтобы наша переменная окружения была доступна на этапе сборки образа, в Dockerfile, то так тоже можно, только для этого надо объявить ее в инструкции `ARG`.

#### Вопрос 1.10. 
✅ Готово! 

#### Вопрос 1.11. 
Самое удобное и современное - использовать Swarm Mode, тогда можно добавить секцию `deploy` и в ней указать, сколько экземпляров (реплик) мы хотим запустить на основе одного Dockerfile. Если Swarm нам недоступен, то второй по приоритетности вариант - при запуске контейнеров использовать опцию `--scale`, чтобы с ее помощью указать, сколько экземпляров и какого именно контейнера нам нужно, например, `docker-compose up --scale upstream-debian=3`.

И третий способ - рабочий, но громоздкий. Так как `upstream-debian` отвечает за один контейнер, то если нам нужно несколько контейнеров, можно написать несколько таких секций вручную: `upstream-debian_1`, `upstream-debian_2` итд. Но devops - это про автоматизацию, а такой подход явно нет, поэтому просто упомянула, что технически это возможно, но не нужно.
Условно, так:
```console
  upstream-debian_1:
    image: upstream-debian
    build:
      context: debian
    hostname: upstream
    restart: unless-stopped

  upstream-debian_2:
    image: upstream-debian
    build:
      context: debian
    hostname: upstream
    restart: unless-stopped
```

## 2. Вопросы по Dockerfile в директории debian
```console
# Вопрос 2.1. Как посмотреть размер образа?
# Вопрос 2.2. Нужно уменьшить суммарный размер образов основанных на debian, какие есть пути решения?
# Вопрос 2.3. Нужно уменьшить размер каждого образа, какие есть пути решения?
FROM debian:bookworm-backports

ARG DEBIAN_FRONTEND=noninteractive

LABEL maintainer="v.pukin@test.ru"

# Вопрос 2.4. Линтер ругается на строку ниже, хотя она работает. Что может быть не так?
RUN apt update &&\
    apt -y install --no-install-recommends \
        apache2 \
        nano \
        vim-tiny &&\
    apt clean &&\
    rm -rf /var/lib/apt/lists/*

# Вопрос 2.5. Чем отличаются ENV от ARG?
ENV APACHE_RUN_USER www-data
# Вопрос 2.6. Как перенести переменные отсюда в .env?
ENV APACHE_RUN_GROUP www-data
ENV APACHE_LOG_DIR /var/log/apache2
ENV APACHE_RUN_DIR /usr/sbin/
ENV APACHE_PID_FILE /tmp/apache.pid

CMD ["apache2", "-D", "FOREGROUND"]
```
## 2. Ответы  
#### Вопрос 2.1.
Размер всех образов можно посмотреть с помощью команды `docker images`.

Более подробную информацию (в т.ч. более точный размер) можно посмотреть с помощью команды `docker inspect <IMAGE_ID_OR_NAME>`, где `<IMAGE_ID_OR_NAME>` заменить на имя или ID контейнера.

#### Вопрос 2.2.
В процессе 

#### Вопрос 2.3.
В процессе 

#### Вопрос 2.4.
В процессе

#### Вопрос 2.5.
`ARG` доступны только во время сборки Dockerfile. Они нам нужны, когда мы хотим передать какие-либо параметры во время сборки образа в формате переменных, а не хардкодом.

`ENV` передается в работающий контейнер и используется там. Они нужны, когда мы хотим установить переменные окружения для наших сервисов в контейнере. Например, указать пользователя, под которым будет работать сервис, и так далее.
> Переменные окружения (ENV) можно переопределить при запуске контейнера с помощью флага `-e`.


#### Вопрос 2.6.
1. Прописываем в `.env` переменные, которые мы будем использовать, и задаем им значения по умолчанию. 
   Здесь нам не надо указывать `ARG` или `ENV`, так как мы просто задаем переменные, по сути, какие хотим:
   ```console
   APACHE_RUN_GROUP=www-data
   APACHE_LOG_DIR=/var/log/apache2
   APACHE_RUN_DIR=/usr/sbin/
   APACHE_PID_FILE=/tmp/apache.pid
   ```

1. Далее, чтобы контейнер знал об этих переменных, нам их надо прокинуть в контейнер через инструкцию environment в docker-compose.yml.
   (Чтобы их использовать в контейнере на больше не нужно их прописывать в Dockerfile, только если они не нужны нам на самомэтапе сборки. Если нужно, прописываем их в докерфайле как ENV).
   Формат: ИМЯ_ПЕРЕМЕННОЙ_ОКРУЖЕНИЯ :${ИМЯ_ПЕРЕМЕННОЙ_ИЗ_ФАЛЙА_ENV}

   Добавляем к сервису apache на debian секцию:
```console
      environment:
      APACHE_RUN_USER: ${APACHE_RUN_USER}
      APACHE_RUN_GROUP: ${APACHE_RUN_GROUP}
      APACHE_LOG_DIR: ${APACHE_LOG_DIR}
      APACHE_RUN_DIR: ${APACHE_RUN_DIR}
      APACHE_PID_FILE: ${APACHE_PID_FILE}
```

> Важно! При использовании docker compose важно расположить файл .env в той же директории, что и docker-compose.yml. Тогда его чтенение произойдет автоматически.

## 3. Вопросы по Dockerfile в директории nginx
```console
FROM nginx:1.24.0

ARG DEBIAN_FRONTEND=noninteractive

LABEL maintainer="v.pukin@test.ru"

RUN apt update &&\
    apt -y install --no-install-recommends \
        nano \
        vim-tiny &&\
    apt clean &&\
    rm -rf /var/lib/apt/lists/*

# Вопрос 3.1. - со звёздочкой - хочу сделать единый файл конфига для debian и centos, как?
COPY default.conf /etc/nginx/conf.d/

# Вопрос 3.2. Хотели менять переменную порта, но что-то не сложилось. Можно поиспользовать в проекте.
# CMD sed -i "s/API_PORT_REPLACE/${API_PORT}/" /etc/nginx/conf.d/default.conf &&\
```

## 3. Ответы 
#### Вопрос 3.1.
Как я поняла из чатика, тут мы хотим сделать так, чтобы nginx перенаправлял запросы на два разных apache, но страничка у них была одна. 
Для этих целей мы можем использовать тома. При работе с `docker compose` (и `docker-compose`) мы можем примонтировать тома в самом `docker-compose.yml`.

А вот далее нам необходимо изменить директорию, в которой nginx будет искать страницы на apache. Для этого нам в файле `default.conf` (которым мы потом заменим `/etc/nginx/conf.d/`) необходимо явно указать путь:
```console
root /var/www/html/hello_apache_page; # Примонтированная директория для единой странички обоих контейнеров на apache
index index.html; # Страничка приветствия
```

#### Вопрос 3.2.
Если кратко, то так:
* Задать переменную в .env (имя + значение)
* Прокинуть ее в контейнер как переменную окружения 
* В файле конфигурации прописать текст (не переменную, просто текст), который далее найдет утилита sed для замены
* В CMD контейнера задать команду, которая найдет нужный текст и заменит его на значение нужной переменной
* В CMD дописать в конце запуск nginx (в этом образе он запускается по умолчанию, но вводя инструкцию CMD мы меняем поведение контейнера по умолчанию)

Как я поняла, есть и другие утилиты для этой задачи, там может отличаться процесс